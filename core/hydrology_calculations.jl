module HydroCalculations



include("well_model.jl")
include("bill_pfront.jl")

using Profile
using ProfileView
using .WellModel
using SpecialFunctions
using Statistics
using PrettyTables # used to print the pressure field in a beautified table
using Dates
using .BillPFront



export calcST, md_to_m2, pfront, generate_datenum_barrels, pfieldcalc_constant_rates, pfieldcalc_monthly_rates, pressureScenario_variable_rate, pfieldcalc_all_rates

"""
Convert permeability from millidarcy (mD) to square meters (m²)
"""
function md_to_m2(permeability_md::Union{Float64, Int64})
    return permeability_md * 10.0^(-3) * 9.9e-13 # convert from mD to m²
end




# Generates the data structure holding injection rates and the start and end years in datenum format
# Format: [datenum, rate], ex. [7.35964e8 7.36329e8; 27000.0 27000.0] --> [start_year end_year; inj_rate inj_rate]
function generate_datenum_barrels(injection_wells, year_range)
    datenum_barrels_per_day = []
    
    # Loop through wells
    for well_id in keys(injection_wells)
        well = injection_wells[well_id]
        start_year = well["injection_rate"]["start_year"]
        end_year = well["injection_rate"]["end_year"]
        rate_per_day = well["injection_rate"]["rate_bbl_day"]

        # Generate rates across the year range
        for year in year_range
            rate = (year >= start_year && year <= end_year) ? rate_per_day : 0.0
            datenum = Dates.DateTime(year, 1, 1) - Dates.DateTime(0, 1, 1) # Simulate datenum-like structure
            push!(datenum_barrels_per_day, [Dates.value(datenum) / 86400, rate])
        end
    end

    return hcat(datenum_barrels_per_day...)  # Combine into a matrix
end


#=
Inputs: 
    h_feet: aquifer thickness
    phi: porosity fraction
    kap: permeability
    rho: fluid density
    mu: dynamic viscosity
    g: accl gravity
    beta: fluid compressibility
    alphav: rock compressibility

Outputs:
    S: Storativity
    T: Transmissivity
    rho: Fluid density
=#
function calcST(h_feet, phi, kap_md, rho, mu, g, beta, alphav)
    # aquifer_thickness from feet to meters
    h_meters = h_feet * 0.3048

    # convert permeability from mD to m²
    kap_m2 = md_to_m2(kap_md)
    
    # Combined compressibility factor
    compressibility_factor = alphav + phi * beta
    
    # storativity S
    S = rho * g * h_meters * (alphav + phi * beta)

    # saturated hydraulic conductivity
    K = kap_m2 * rho * g / mu

    # transmissivity T
    T = K * h_meters
    
    return S, T, rho
end



# using multiple dispatch in case the function gets called with two arguments
function pfront(T::Float64, S::Float64)
    # m^2/sec storativity
    S = 5.4e-5
    # m^2/sec transmissivity
    T = 4.5e-6
end


#=
# using Bill's function (How should we implement the output_date parameter?)
function pfieldcalc(xGrid_km::AbstractMatrix, yGrid_km::AbstractMatrix, STRho::Tuple{Float64, Float64, Float64}, days::Union{Vector{Float64}, Vector{Integer}}, bpds::Union{Vector{Float64}, Vector{Integer}}, xwell_km::Union{Float64, Integer, AbstractRange, AbstractVector}, ywell_km::Union{Float64, Integer}, output_date::Date)
    

    # initialize data matrix (50x50)
    pfieldResult = zeros(Float64, size(xGrid_km))


    # grid distances to well (in meters)
    # calculate radial distances from the well located at xwell, ywell, to various points (x,y) on the grid using complex numbers
    
    #= FSP Radial Distance Calculation
    difflocs = xGrid_km .+ im .* yGrid_km .- (xwell_km .+ im * ywell_km) # VERIFIED

    R = abs.(difflocs) # radial distance in km
    
    R_meters = R * 1e3 # radial distance in meters VERIFIED
    =#

    R = sqrt.((xGrid_km .- xwell_km).^2 .+ (yGrid_km .- ywell_km).^2)
    R_meters = R * 1e3 # convert to meters

    R_meters_flattened = vec(R_meters)

    # call pressureScenario for this well
    # radially symmetric, finite thickness pressure front calculation that loops over time
    pfrontResult_flat = pressureScenario_constant_rate(bpds, days, R_meters_flattened, STRho)

    # Reshape back to original grid shape
    pfrontResult = reshape(pfrontResult_flat, size(xGrid_km))

    return pfrontResult
    

end # pfieldcalc Bill implementaiton function
=#


# Computes the pressure field generated by a set of wells with variable rate using
# linear superposition from a simple radially symmetric pressure model
function pfieldcalc_monthly_rates(
    xGrid_km::AbstractMatrix,
    yGrid_km::AbstractMatrix,
    STRho::Tuple{Float64, Float64, Float64},
    days::Vector{Float64},
    bpds::AbstractVector{Float64},
    xwell_km::Union{Float64, Integer},
    ywell_km::Union{Float64, Integer},
    output_date::Date
    )

    # get distance from each grid point to the well (in km)
    R_km = sqrt.((xGrid_km .- xwell_km).^2 .+ (yGrid_km .- ywell_km).^2)
    # convert to meters
    R_meters = R_km * 1e3
    # flatten the matrix
    R_meters_flattened = vec(R_meters)

    pfront_flat = pressureScenario_variable_rate(bpds, days, R_meters_flattened, STRho)

    # Reshape back to original grid shape
    pfront_2d = reshape(pfront_flat, size(xGrid_km))

    return pfront_2d

end




"""
Inputs:
- bpds: Injection rates in bbl/day (all the same).
- days: The day-steps for injection.
- r_meters: Distances from the well in meters.
- STRho: Tuple (S, T, rho) -> storativity, transmissivity, fluid density.

Output:
- dp_psi: A vector of pressure changes in PSI, one per distance in r_meters.
"""

function pressureScenario_variable_rate(
    bpds::Vector{Float64},
    days::Vector{Float64},
    r_meters::AbstractVector{Float64},
    STRho::Tuple{Float64, Float64, Float64}
    )

    S, T, rho = STRho
    g = 9.81

    # if no injection data, return zeros
    if isempty(bpds)
        return zeros(length(r_meters))
    end

    # final time (days -> seconds)
    t_final_sec = maximum(days) * 86400.0
    if t_final_sec <= 0
        return zeros(length(r_meters))
    end

    n = length(bpds)
    dp_psi = zeros(length(r_meters))

    # 1) Compute rate changes (dQ[i]) for each step
    dQ = similar(bpds)
    dQ[1] = bpds[1]
    for i in 2:n
        dQ[i] = bpds[i] - bpds[i-1]
    end

    # 2) For each time step, superimpose the pressure changes
    for i in 1:n
        t_i_sec = days[i] * 86400.0
        dt = t_final_sec - t_i_sec

        # if dt <=0 --> final time is before this injection started
        if dt <= 0
            continue
        end

        # convert bbl/day -> m³/s
        dQ_m3_s = dQ[i] * 1.84013e-6

        u = (r_meters .^2) .* S ./(4 * T * dt)

        # Head from Theis: Δh(r) = (ΔQ / (4πT)) * expint(u)
        head = (dQ_m3_s / (4 * pi * T)) .* expint.(u)

        # head --> Pa --> PSI
        dp_pascals = head .* (rho * g)
        dp_tmp = dp_pascals ./ 6894.76

        # Handle any infinities or NaN
        dp_tmp[.!isfinite.(dp_tmp)] .= 0.0

        dp_psi .+= dp_tmp
    end

    return dp_psi

end






# Computes the pressure field generated by a set of wells with constant rate using
# linear superposition from a simple radially symmetric pressure model
function pfieldcalc_constant_rates(
    xGrid_km::AbstractMatrix, 
    yGrid_km::AbstractMatrix, 
    STRho::Tuple{Float64, Float64, Float64}, 
    days::Vector{Float64}, 
    bpds::Vector{Float64}, 
    xwell_km::Union{Float64, Integer}, 
    ywell_km::Union{Float64, Integer}, 
    output_date::Date
    )

    # 1) get distance from each grid point to the well (in km)
    R_km = sqrt.((xGrid_km .- xwell_km).^2 .+ (yGrid_km .- ywell_km).^2)

    # 2) convert to meters
    R_meters = R_km * 1e3

    # 3) Flatten the matrix
    R_meters_flattened = vec(R_meters)

    # 4) call pressureScenario for this well
    pfrontResult_flat = pressureScenario_constant_rate(bpds, days, R_meters_flattened, STRho)

    # 5) Reshape back to original grid shape
    pfrontResult_2d = reshape(pfrontResult_flat, size(xGrid_km))

    return pfrontResult_2d

end


# pressure field calculation (PORTAL VERSION)
# runs pessureScenario (pressure front) function on every grid point
# works with both both constant and variable injection rates

function pfieldcalc_all_rates(
    xGrid_km::AbstractMatrix, 
    yGrid_km::AbstractMatrix, 
    STRho::Tuple{Float64, Float64, Float64}, 
    days::Vector{Float64}, 
    bpds::Vector{Float64}, 
    xwell_km::Union{Float64, Integer}, 
    ywell_km::Union{Float64, Integer}, 
    coordinate_type::String="latlon"
    )
    
    # IMPORTANT: Due to the flipped meshgrid call in create_spatial_grid_latlon:
    # - xGrid_km actually contains latitude values
    # - yGrid_km actually contains longitude values
    # This requires adjusting the parameter order in the haversine_distance call
    
    # Correct parameter order: haversine_distance(lat1, lon1, lat2, lon2)
    R_km = haversine_distance.(xGrid_km, yGrid_km, ywell_km, xwell_km)
    
    # 2) convert to meters
    R_meters = R_km * 1000.0

    # Output distance statistics (min/max values)
    min_distance = minimum(R_meters)
    max_distance = maximum(R_meters)
    println("  * Distance range: $min_distance m to $max_distance m from well")

    # 3) Flatten the matrix
    R_meters_flattened = vec(R_meters)

    # 4) call pressureScenario for this well
    S, T, rho = STRho
    
    pfrontResult_flat = pressureScenario_Rall(bpds, days, R_meters_flattened, STRho)
    
    # Ensure no negative pressure values exist
    pfrontResult_flat = max.(0.0, pfrontResult_flat)

    # 5) Reshape back to original grid shape
    pfrontResult_2d = reshape(pfrontResult_flat, size(xGrid_km))

    # Output pressure statistics (min/max values)
    #min_pressure = minimum(pfrontResult_2d)
    #max_pressure = maximum(pfrontResult_2d)

    
    

    #println("  * Pressure change range: $min_pressure psi to $max_pressure psi")

    return pfrontResult_2d
end


"""
    haversine_distance(lat1::Float64, lon1::Float64, lat2::Float64, lon2::Float64)

Calculate the great-circle distance between two points on Earth using the Haversine formula.

Parameters:
- lat1, lon1: Latitude and longitude of the first point in degrees
- lat2, lon2: Latitude and longitude of the second point in degrees

Returns:
- Distance between the points in kilometers
"""
function haversine_distance(lat1::Float64, lon1::Float64, lat2::Float64, lon2::Float64)
    # Earth radius in kilometers
    R = 6371.0
    
    # Convert degrees to radians
    lat1_rad = deg2rad(lat1)
    lon1_rad = deg2rad(lon1)
    lat2_rad = deg2rad(lat2)
    lon2_rad = deg2rad(lon2)
    
    # Haversine formula
    dlat = lat2_rad - lat1_rad
    dlon = lon2_rad - lon1_rad
    a = sin(dlat/2)^2 + cos(lat1_rad) * cos(lat2_rad) * sin(dlon/2)^2
    c = 2 * atan(sqrt(a), sqrt(1-a))
    
    # Distance in kilometers
    return R * c
end

# keep original (for backwards compatibility, will remove later)
#=
function pfieldcalc_all_rates(
    xGrid_km::AbstractMatrix, 
    yGrid_km::AbstractMatrix, 
    STRho::Tuple{Float64, Float64, Float64}, 
    days::Vector{Float64}, 
    bpds::Vector{Float64}, 
    xwell_km::Union{Float64, Integer}, 
    ywell_km::Union{Float64, Integer}, 
    output_date::Date
    )
    
    return pfieldcalc_all_rates(
        xGrid_km, yGrid_km, STRho, days, bpds, xwell_km, ywell_km, "latlon"
    )
end
=#


# pressure field calculation (Geomechanics version)
# multiple dispatch: wehn called with faults, it uses vectors instead of matrices
# find the distance from the well to the fault
# call pressureScenario for this well
function pfieldcalc_all_rates(
    x_fault_deg::Union{Float64, Integer}, 
    y_fault_deg::Union{Float64, Integer}, 
    STRho::Tuple{Float64, Float64, Float64}, 
    days::Vector{Float64}, 
    bpds::Vector{Float64}, 
    xwell_deg::Union{Float64, Integer}, 
    ywell_deg::Union{Float64, Integer}
    )

    #println("fault coordinates: longitude = $x_fault_deg, latitude = $y_fault_deg")
    #println("well coordinates: longitude = $xwell_deg, latitude = $ywell_deg")

    #get distance from each well to the faul (in km)
    #R_km = sqrt((x_fault_km - xwell_km)^2 + (y_fault_km - ywell_km)^2)
    R_km = haversine_distance(y_fault_deg, x_fault_deg, ywell_deg, xwell_deg)


    #println("Distance from well to fault (pfieldcalc_all_rates): $R_km km")

    #convert to meters
    R_meters = R_km * 1e3

    
    
    # Convert R_meters to a vector since pressureScenario_Rall expects a vector
    R_meters_vec = [R_meters]
    pfrontResult = pressureScenario_Rall(bpds, days, R_meters_vec, STRho)
    
    # Ensure no negative pressure values
    pfrontResult = max.(0.0, pfrontResult)
    
    # Return the single value result
    return pfrontResult[1]

end


    
    
end # module